{"version":3,"file":"drawTabbableOnCanvas.js","sourceRoot":"","sources":["../../src/clientSideScripts/drawTabbableOnCanvas.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ElementCoordinate } from './drawTabbableOnCanvas.interfaces'\nimport type { CircleOptions, LineOptions, TabbableOptions } from '../commands/tabbable.interfaces'\n\n/**\n * This method is based on this blog post\n * https://vivrichards.co.uk/accessibility/automating-page-tab-flows-using-visual-testing-and-javascript\n * by Viv Richards and optimized for using Canvas\n */\nexport default function drawTabbableOnCanvas(drawOptions: TabbableOptions) {\n    // 1. Scroll to top of page\n    window.scrollTo(0, 0)\n\n    // 2. Insert canvas\n    const width = window.innerWidth\n    const height = getDocumentScrollHeight()\n    const canvasNode = `<canvas id=\"wic-tabbable-canvas\" width=\"${width}\" height=\"${height}\" style=\"position:absolute;top:0;left:0;z-index:999999;\">`\n    document.body.insertAdjacentHTML('afterbegin', canvasNode)\n\n    // 3. Get all the elements\n    const accessibleElements = tabbable()\n\n    // 4a. Iterate over all accessibleElements and get the coordinates\n    const elementCoordinates: ElementCoordinate[] = accessibleElements.map((node) => {\n        const currentElement = node.getBoundingClientRect()\n\n        return {\n            x: currentElement.left + currentElement.width / 2,\n            y: currentElement.top + currentElement.height / 2,\n        }\n    })\n    // 4b. Add the starting coordinates\n    elementCoordinates.unshift({ x: 0, y: 0 })\n    // 4c. Iterate over all coordinates and draw lines and circles\n    elementCoordinates.forEach((elementCoordinate, i) => {\n        if (i === 0) {\n            return\n        }\n\n        drawLine(drawOptions.line!, elementCoordinates[i - 1], elementCoordinate)\n        drawCircleAndNumber(drawOptions.circle!, elementCoordinate, i)\n    })\n\n    /**\n   * Draw a line\n   */\n    function drawLine(options: LineOptions, start: ElementCoordinate, end: ElementCoordinate): void {\n        const tabbableCanvasContext = (<HTMLCanvasElement>document.getElementById('wic-tabbable-canvas')).getContext('2d')\n\n        if (!tabbableCanvasContext) {\n            return\n        }\n\n        // Draw the line\n        tabbableCanvasContext.beginPath()\n        tabbableCanvasContext.globalCompositeOperation = 'destination-over'\n        tabbableCanvasContext.lineWidth = options.width!\n        tabbableCanvasContext.strokeStyle = options.color!\n        tabbableCanvasContext.moveTo(start.x, start.y)\n        tabbableCanvasContext.lineTo(end.x, end.y)\n        tabbableCanvasContext.stroke()\n    }\n\n    /**\n   * Draw a circle\n   */\n    function drawCircleAndNumber(options: CircleOptions, position: ElementCoordinate, i: number): void {\n        const tabbableCanvasContext = (<HTMLCanvasElement>document.getElementById('wic-tabbable-canvas')).getContext('2d')\n\n        if (!tabbableCanvasContext) {\n            return\n        }\n\n        // Draw circle\n        tabbableCanvasContext.beginPath()\n        tabbableCanvasContext.globalCompositeOperation = 'source-over'\n        tabbableCanvasContext.fillStyle = options.backgroundColor!\n        tabbableCanvasContext.arc(position.x, position.y, options.size!, 0, Math.PI * 2, true)\n        tabbableCanvasContext.fill()\n        // Draw border\n        tabbableCanvasContext.lineWidth = options.borderWidth!\n        tabbableCanvasContext.strokeStyle = options.borderColor!\n        tabbableCanvasContext.stroke()\n\n        if (options.showNumber) {\n            // Set the text\n            tabbableCanvasContext.font = `${options.fontSize}px ${options.fontFamily}`\n            tabbableCanvasContext.textAlign = 'center'\n            tabbableCanvasContext.textBaseline = 'middle'\n            tabbableCanvasContext.fillStyle = options.fontColor!\n            tabbableCanvasContext.fillText(i.toString(), position.x, position.y)\n        }\n    }\n\n    /**\n   * Below code is coming from https://github.com/davidtheclark/tabbable\n   * and is modified a bit to work inside the browser.\n   * The original module couldn't be used for injection and didn't support TypeScript\n   */\n\n    /**\n   * Get all tabbable elements based on tabindex and then regular dom order\n   */\n    function tabbable(): HTMLElement[] {\n        const regularTabbables = []\n        const orderedTabbables = []\n        const candidateSelectors = [\n            'input',\n            'select',\n            'textarea',\n            'a[href]',\n            'button',\n            '[tabindex]',\n            'audio[controls]',\n            'video[controls]',\n            '[contenteditable]:not([contenteditable=\"false\"])',\n        ].join(',')\n        const candidates: NodeListOf<HTMLElement> = document.querySelectorAll(candidateSelectors)\n\n        for (let i = 0; i < candidates.length; i++) {\n            const candidate = candidates[i]\n\n            if (!isNodeMatchingSelectorTabbable(candidate)) {\n                continue\n            }\n\n            const candidateTabindex = getTabindex(candidate)\n\n            if (candidateTabindex === 0) {\n                regularTabbables.push(candidate)\n            } else {\n                orderedTabbables.push({\n                    documentOrder: i,\n                    tabIndex: candidateTabindex,\n                    node: candidate,\n                })\n            }\n        }\n\n        return Array.prototype.slice.call(\n            orderedTabbables\n                .sort(<any>sortOrderedTabbables)\n                .map((a) => a.node)\n                .concat(regularTabbables),\n        )\n    }\n\n    /**\n   * Is the node tabbable\n   */\n    function isNodeMatchingSelectorTabbable(node: HTMLElement): boolean {\n        return !(!isNodeMatchingSelectorFocusable(node) || isNonTabbableRadio(node) || getTabindex(node) < 0)\n    }\n\n    /**\n   * Check if the node has a focused state\n   */\n    function isNodeMatchingSelectorFocusable(node: HTMLElement): boolean {\n        return !(node.hasAttribute('disabled') || node.getAttribute('disabled') || isHiddenInput(node) || isHidden(node))\n    }\n\n    /**\n   * Get the tab index of the node\n   */\n    function getTabindex(node: HTMLElement): number {\n        const tabindexAttr = parseInt(node.getAttribute('tabindex')!, 10)\n\n        if (!isNaN(tabindexAttr)) {\n            return tabindexAttr\n        }\n        // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n        // so if they don't have a tabindex attribute specifically set, assume it's 0.\n        if (isContentEditable(node)) {\n            return 0\n        }\n\n        return node.tabIndex\n    }\n\n    /**\n   * Return ordered tabbable nodes\n   */\n    function sortOrderedTabbables(nodeA: HTMLElement, nodeB: HTMLElement): number {\n        return nodeA.tabIndex === nodeB.tabIndex\n            ? // This is so bad :(, fix this!\n            (<any>nodeA).documentOrder - (<any>nodeB).documentOrder\n            : nodeA.tabIndex - nodeB.tabIndex\n    }\n\n    /**\n   * Is the content editable\n   */\n    function isContentEditable(node: HTMLElement): boolean {\n        return node.contentEditable === 'true'\n    }\n\n    /**\n   * Is the node an input\n   */\n    function isInput(node: HTMLElement): boolean {\n        return node.tagName === 'INPUT'\n    }\n\n    /**\n   * Is the input hidden\n   */\n    function isHiddenInput(node: HTMLElement): boolean {\n        return isInput(node) && (<HTMLInputElement>node).type === 'hidden'\n    }\n\n    /**\n   * Is the node a radio input\n   */\n    function isRadio(node: HTMLElement): boolean {\n        return isInput(node) && (<HTMLInputElement>node).type === 'radio'\n    }\n\n    /**\n   * Is the node a radio input and can it be tabbed\n   */\n    function isNonTabbableRadio(node: HTMLElement): boolean {\n        return isRadio(node) && !isTabbableRadio(<HTMLInputElement>node)\n    }\n\n    /**\n   * Get the checked radio input\n   */\n    // @ts-ignore\n    function getCheckedRadio(nodes: HTMLInputElement[]) {\n        for (let i = 0; i < nodes.length; i++) {\n            if (nodes[i].checked) {\n                return nodes[i]\n            }\n        }\n    }\n\n    /**\n   * Is the radio input tabbable\n   */\n    function isTabbableRadio(node: HTMLInputElement): boolean {\n        if (!node.name) {\n            return true\n        }\n        // This won't account for the edge case where you have radio groups with the same\n        // in separate forms on the same page.\n        // This is bad :(, but don't know how to fix this typing\n        const radioSet = (<any>node.ownerDocument).querySelectorAll(`input[type=\"radio\"][name=\"${node.name}\"]`)\n        const checked = getCheckedRadio(radioSet)\n\n        return !checked || checked === node\n    }\n\n    /**\n   * Is the node hidden\n   */\n    function isHidden(node: HTMLElement): boolean {\n        // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,\n        // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.\n        return node.offsetParent === null || getComputedStyle(node).visibility === 'hidden'\n    }\n\n    /**\n   * Get the document scroll height\n   */\n    function getDocumentScrollHeight(): number {\n        const viewPortHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0)\n        const scrollHeight = document.documentElement.scrollHeight\n        const bodyScrollHeight = document.body.scrollHeight\n\n        // In some situations the default scrollheight can be equal to the viewport height\n        // but the body scroll height can be different, then return that one\n        if (viewPortHeight === scrollHeight && bodyScrollHeight > scrollHeight) {\n            return bodyScrollHeight\n        }\n\n        // In some cases we can have a challenge determining the height of the page\n        // due to for example a `vh` property on the body element.\n        // If that is the case we need to walk over all the elements and determine the highest element\n        // this is a very time consuming thing, so our last hope :(\n        let pageHeight = 0\n        let largestNodeElement = document.querySelector('body')\n\n        if (bodyScrollHeight === scrollHeight && bodyScrollHeight === viewPortHeight) {\n            findHighestNode(document.documentElement.childNodes)\n\n            // There could be some elements above this largest element,\n            // add that on top\n            return pageHeight + largestNodeElement?.getBoundingClientRect().top!\n        }\n\n        // The scrollHeight is good enough\n        return scrollHeight\n\n        /**\n     * Find the largest html element on the page\n     */\n        // This is so bad :(, fix the typings!!!\n        function findHighestNode(nodesList: any) {\n            for (let i = nodesList.length - 1; i >= 0; i--) {\n                const currentNode = nodesList[i]\n\n                /* istanbul ignore next */\n                if (currentNode.scrollHeight && currentNode.clientHeight) {\n                    const elHeight = Math.max(currentNode.scrollHeight, currentNode.clientHeight)\n                    pageHeight = Math.max(elHeight, pageHeight)\n                    if (elHeight === pageHeight) {\n                        largestNodeElement = currentNode\n                    }\n                }\n\n                if (currentNode.childNodes.length) {\n                    findHighestNode(currentNode.childNodes)\n                }\n            }\n        }\n    }\n}\n"]}